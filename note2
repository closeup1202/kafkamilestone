cors 
.allowCredentials(true) //브라우저가 쿠키와 같은 자격 증명을 함께 보내야 하는지 여부 crps 토큰 jwt 토큰 등		
		
------------------------------------------------------------------------------------			
		
toString 을 항상 재정의 하라
이펙티브 자바 3판 아이템 12 에서는 toString 메소드를 항상 재정의 하라고 말함

toString 이 잘 구현된 클래스는 
사용하기 편하고, 디버깅이 쉽다. 
객체를 출력하기만 하면, 
객체가 가지고 있는 모든 정보를 확인할 수 있다. 
우리가 직접 호출하지 않아도, 로깅을 하거나 에러메세지를 출력할 때에도 유용하게 사용할 수 있다.

toString 은 객체가 가진 주요 정보를 모두 반환하는 것이 좋다. 이상적으로는 스스로를 완벽히 설명하는 문자열이어야 한다. 
위에서 만든 Car 클래스의 toString 은 아래와 같이 오버라이딩 할 수 있겠다.

 final로 선언된 인자는 메소드 내에서 변경이 불가능합니다. readonly
 
 예를 들어 
 
public void func(final int number){
 	number = 10; 
 	컴파일 에러
 	
}

stream ---------------------------------------------------------------------------
		
데이터 소스마다 다른 방식으로 다뤄야한다는 것
이를 테면, List를 정렬할 때는 Collections.sort()를 사용 | 배열을 정렬할 때는 Arrays.sort()를 사용해야 한다. 

이러한 문제점을 해결한 것이 스트림
데이터 소스를 추상화하고, 데이터를 다루는 데 자주 사용되는 메서드들을 정의해 놓았음. 
데이터 소스가 무엇이던 간에 같은 방식으로 다룰 수 있게 되어 코드의 재사용성이 높아짐

스트림은 원본을 보존하는 readonly의 일회성

스트림은 내부 반복을 사용하는데, 내부 반복이 뭐냐면 메서드 안에 반복 기능이 있다는 것임

컬렉션은 외부적 반복, 즉 명시적 컬렉션의 항목을 하나씩 가져와서 처리한다. 
내부반복을 이용한다면 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있다.

----------------------------------------------------------------------------------	

local 각 개발자마다, 설치된 서버 환경
dev 서버 개발 환경
qa는 테스팅 환경
staging 운영 환경과 거의 동일환 환경을 만들어 놓고, 운영환경으로 이관하기 전에, 여러 가지 비 기능적인 부분을 검증하는 환경
시큐리티, 성능, 장애

----------------------------------------------------------------------------------	

Entity의 상태

Entity의 상태는 크게 4가지 종류가 있다.
1. Transient: 객체를 생성하고, 값을 주어도 JPA나 hibernate가 그 객체에 관해 아무것도 모르는 상태. 즉, 데이터베이스와 매핑된 것이 아무것도 없다.
2. Persistent: 저장을 하고나서, JPA가 아는 상태(관리하는 상태)가 된다. 그러나 .save()를 했다고 해서, 이 순간 바로 DB에 이 객체에 대한 데이터가 들어가는 것은 아니다. 
               JPA가 persistent 상태로 관리하고 있다가, 후에 데이터를 저장한다.
               (1차 캐시, Dirty Checking(변경사항 감지), Write Behind(최대한 늦게, 필요한 시점에 DB에 적용) 등의 기능을 제공한다)
3. Detached: JPA가 더이상 관리하지 않는 상태. JPA가 제공해주는 기능들을 사용하고 싶다면, 다시 persistent 상태로 돌아가야한다.
4. Removed: JPA가 관리하는 상태이긴 하지만, 실제 commit이 일어날 때, 삭제가 일어난다.

cascade는 이러한 상태 변화를 전이시키는 것이다.

--------------------------------------------------------------------------
기본 생성자의 접근 제어를 PROTECTED로 설정해놓게 되면  *같은 패키지 내에서만 접근 가능
무분별한 객체 생성에 대해 한번 더 체크할 수 있는 수단이 되기 때문

Class 'StoreEntity' should have [public, protected] no-arg constructor 

private는 안 됨! 왜? proxy 객체를 사용하기 때문

The no-arg constructor must be public or protected.
// Entity 클래스는 매개변수가 없는 생성자의 접근 레벨이 public 또는 protected로 해야 한다.

An instance variable must be directly accessed only from within the methods of the entity by the entity instance itself.
// 인스턴스 변수는 직접 접근이 아닌 내부 메소드로 접근해야 한다.

엔티티 조회 시  HibernateProxy 사용 

Proxy 객체로 조회 되는데 접근 권한이 PRIVATE이므로 
Proxy 객체 생성하는 로직에서 오류가 발생

--------------------------------------------------------------------------

조인 포인트는 추상적인 개념이다. AOP를 적용할 수 있는 모든 지점이라 생각하면 된다.
스프링 AOP는 프록시 방식을 사용하므로 조인 포인트는 항상 메소드 실행 지점으로 제한된다

어드바이스(Advice)
부가 기능
특정 조인 포인트에서 Aspect에 의해 취해지는 조치
Around(주변), Before(전), After(후)와 같은 다양한 종류의 어드바이스가 있음

포인트컷 : 조인 포인트 중에서 어드바이스가 적용될 위치를 선별하는 기능 | 주로 AspectJ 표현식을 사용해서 지정

--------------------------------------------------------------------------------

@Builder로 만들려면 @AllArgsConstructor 필요 없으면 에러 뜸

--------------------------------------------------------------------------------

[ 객체 - JSON ] 변환 시 Key의 이름을 설정할 수 있음

클라이언트와 서버의 표기법이 달라서 발생하는 문제를 @JsonProperty 어노테이션을 통해 해결

--------------------------------------------------------------------------------

오프셋을 직접 관리하는 방법도 있지만, 각 파티션에 대한 오프셋 정보 관리, 파티션 변경에 대한 관리 등이 매우 번거로울 수 있습니다. 
그래서 카프카에서는 직접 관리하지 않는 방법인 자동 커밋을 지원합니다. 
이 방법은 가장 많이 사용